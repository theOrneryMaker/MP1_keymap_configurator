<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MP1 Macropad Configurator</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: Arial, sans-serif;
            background: #0f0b1a;
            color: #e0d8ff;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #1a1625;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        }
        
        h1 {
            text-align: center;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            font-size: 3.5em;
            color: #ff8c42;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255,140,66,0.5);
        }
        
        .section {
            background: #16213e;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 10px;
            border-left: 4px solid #ff8c42;
        }
        
        .section h2 {
            color: #ff8c42;
            margin-bottom: 15px;
            font-size: 1.4em;
        }
        
        label {
            display: block;
            margin: 10px 0 5px;
            color: #b19cd9;
            font-weight: bold;
        }
        
        input[type="text"],
        input[type="number"],
        select,
        textarea {
            width: 100%;
            padding: 10px;
            background: #0f0f1e;
            border: 1px solid #555;
            color: #e0d8ff;
            border-radius: 5px;
            font-size: 1em;
        }
        
        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: #ff8c42;
        }
        
        /* Textarea wrapper for positioning expand button */
        .textarea-wrapper {
            position: relative;
        }
        
        /* Expand button in bottom-right corner */
        .expand-button {
            position: absolute;
            bottom: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            background: #ff8c42;
            border: none;
            border-radius: 4px;
            color: #0f0b1a;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        
        .expand-button:hover {
            background: #ffa666;
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255,140,66,0.6);
        }
        
        /* Modal overlay */
        .json-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .json-modal.active {
            display: flex;
        }
        
        /* Modal content */
        .json-modal-content {
            background: #1a1625;
            border-radius: 15px;
            border: 2px solid #ff8c42;
            width: 90%;
            max-width: 1000px;
            height: 80%;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 50px rgba(0,0,0,0.9);
        }
        
        /* Modal header */
        .json-modal-header {
            padding: 20px 25px;
            border-bottom: 2px solid #443355;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .json-modal-header h3 {
            color: #ff8c42;
            margin: 0;
            font-size: 1.5em;
        }
        
        .json-modal-close {
            background: #ff4444;
            color: white;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        
        .json-modal-close:hover {
            background: #ff6666;
            transform: rotate(90deg);
        }
        
        /* Modal body */
        .json-modal-body {
            padding: 25px;
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .json-modal-body textarea {
            flex: 1;
            resize: none;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
        }
        
        /* Modal footer */
        .json-modal-footer {
            padding: 20px 25px;
            border-top: 2px solid #443355;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        button {
            background: #ff8c42;
            color: #000;
            border: none;
            padding: 12px 12px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #ffa666;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255,140,66,0.4);
        }
        
        /* Override for sequence remove button */
        .sequence-step-remove {
            all: unset;
            background: #c0392b !important;
            color: white !important;
            border-radius: 50% !important;
            cursor: pointer !important;
            font-weight: bold !important;
            font-size: 1em !important;
            width: 28px !important;
            height: 28px !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            transition: background 0.2s !important;
            box-sizing: border-box !important;
            padding: 0 !important;
            margin: 0 !important;
            flex-shrink: 0 !important;
            margin-top: 12px !important;
        }
        
        .sequence-step-remove:hover {
            background: #e74c3c !important;
            transform: none !important;
            box-shadow: none !important;
        }
        
        .key-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .key-config {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #444;
            min-width: 300px;
            max-width: 100%;
            transition: all 0.3s;
        }
        
        .key-config:hover {
            border-color: #ff8c42;
            box-shadow: 0 0 15px rgba(255, 140, 66, 0.5);
        }
        
        .key-config h3 {
            color: #ff8c42;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .layer-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .layer-tab {
            background: #2a2544;
            padding: 6px 12px;
            border-radius: 8px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s;
        }
        
        .layer-tab:hover {
		    background: #ffa666;
            border-color: #ff8c42;
			transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255,140,66,0.4);
        }
        
        .layer-tab.active {
            background: #ff8c42;
            color: #000;
            font-weight: bold;
        }
		.layer-tab.active:hover {
            background: #ffa666;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255,140,66,0.4);
        }
        
        .input-group {
            margin: 10px 0;
        }
        
        .combo-selector {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        .combo-selector select {
            flex: 1;
        }
        
        .hidden {
            display: none;
        }
        
        #jsonOutput {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            height: 400px;
            resize: vertical;
        }
        
        .help-link {
            display: inline-block;
            margin: 10px 0;
            color: #ff8c42;
            text-decoration: none;
        }
        
        .help-link:hover {
            text-decoration: underline;
        }
        
        /* Sequence Builder Styles */
        .sequence-builder {
            background: #1a1a2e;
            border: 2px solid #ff8c42;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }
        
        .sequence-step {
            background: #16213e;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .sequence-step-number {
            background: #ff8c42;
            color: #000;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-shrink: 0;
        }
        
        .sequence-step-content {
            flex: 1;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .sequence-step select,
        .sequence-step input {
            background: #0f0f1e;
            border: 1px solid #555;
            color: #e0d8ff;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        
        .sequence-step-remove {
            background: #c0392b;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .sequence-step-remove:hover {
            background: #e74c3c;
        }
        
        .sequence-add-step {
            background: #27ae60;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            margin-top: 10px;
        }
        
        .sequence-add-step:hover {
            background: #2ecc71;
        }
        
        .combo-key-selector {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .combo-key-selector select {
            min-width: 120px;
        }
        
        .help-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #f78b40;
            color: white;
            border: none;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2em;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            z-index: 10;
        }
        
        .help-button:hover {
            background: #ff8c42;
            transform: scale(1.1);
        }
        
        .header-section {
            position: relative;
        }
        
        .checkbox-inline {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        
        .checkbox-inline input[type="checkbox"] {
            width: auto;
            margin: 0;
        }
        
        .checkbox-inline label {
            margin: 0;
            display: inline;
        }
        
        .label-with-button {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0 5px;
        }
        
        .macro-recorder-button {
            background: #ff8c42;
            color: #000;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.85em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            white-space: nowrap;
        }
        
        .macro-recorder-button:hover {
            background: #ffa666;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255,140,66,0.4);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>MP1 Macropad Configurator</h1>
        
        <div class="section header-section">
			<h2>Kymap.json Loader</h2>
            <button class="help-button" onclick="openHelp()" title="User Guide">?</button>
            <div class="input-group">
                <input type="file" id="fileInput" accept=".json">
            </div>
        </div>
        
        <div class="section">
            <h2>Layer Configuration</h2>
			<div class="input-group">
                <label for="numLayers">Number of Layers:</label>
                <input type="number" id="numLayers" min="2" max="10" value="3">
                <button onclick="updateLayerCount()">Update Layers</button>
            </div>
				<div class="layer-tabs" id="layerTabs">
			</div>
            <div id="layerContent"></div>
        </div>
        
        <div class="section">
            <h2>Keymap.json Generator</h2>
            <button onclick="generateKeymap()">Generate keymap.json</button>
            <button onclick="saveKeymap()">Save keymap.json</button>
            <button onclick="clearAll()">Clear</button>
            <textarea id="jsonOutput" readonly></textarea>
        </div>
    </div>

    <script>
        // Global state
        let numLayers = 3;
        let currentLayer = 0;
        let keymapData = {
            layer_names: [],
            secret_layer: 0,
            default_layer: 1,
            keymap: [],
            icons: [],
            encoder_icons: [],
            encoder_actions: []
        };
        let sequenceBuilders = [];

        // Keycode list
        const KEYCODES = [
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
            'ONE', 'TWO', 'THREE', 'FOUR', 'FIVE', 'SIX', 'SEVEN', 'EIGHT', 'NINE', 'ZERO',
            'ENTER', 'ESCAPE', 'BACKSPACE', 'TAB', 'SPACE', 'MINUS', 'EQUALS',
            'LEFT_BRACKET', 'RIGHT_BRACKET', 'BACKSLASH', 'SEMICOLON', 'QUOTE',
            'GRAVE_ACCENT', 'COMMA', 'PERIOD', 'FORWARD_SLASH',
            'CAPS_LOCK', 'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12',
            'PRINT_SCREEN', 'SCROLL_LOCK', 'PAUSE', 'INSERT', 'HOME', 'PAGE_UP',
            'DELETE', 'END', 'PAGE_DOWN',
            'RIGHT_ARROW', 'LEFT_ARROW', 'DOWN_ARROW', 'UP_ARROW',
            'KEYPAD_NUMLOCK', 'KEYPAD_FORWARD_SLASH', 'KEYPAD_ASTERISK',
            'KEYPAD_MINUS', 'KEYPAD_PLUS', 'KEYPAD_ENTER',
            'KEYPAD_ONE', 'KEYPAD_TWO', 'KEYPAD_THREE', 'KEYPAD_FOUR',
            'KEYPAD_FIVE', 'KEYPAD_SIX', 'KEYPAD_SEVEN', 'KEYPAD_EIGHT',
            'KEYPAD_NINE', 'KEYPAD_ZERO', 'KEYPAD_PERIOD',
            'LEFT_CONTROL', 'LEFT_SHIFT', 'LEFT_ALT', 'LEFT_GUI',
            'RIGHT_CONTROL', 'RIGHT_SHIFT', 'RIGHT_ALT', 'RIGHT_GUI',
            'CONTROL', 'SHIFT', 'ALT', 'GUI', 'WINDOWS', 'COMMAND'
        ];

        const CONSUMER_CONTROLS = ['PREV', 'PLAYPAUSE', 'NEXT', 'MUTE', 'VOL_UP', 'VOL_DN'];

        // ============================================
        // SEQUENCE BUILDER CLASS
        // ============================================
        class SequenceBuilder {
            constructor(containerId, initialSequence = []) {
                this.container = document.getElementById(containerId);
                this.sequence = Array.isArray(initialSequence) ? [...initialSequence] : [];
                this.render();
            }
            
            addStep(type = 'string') {
                this.sequence.push({
                    type: type,
                    value: type === 'delay' ? 0.1 : (type === 'combo' ? [] : ''),
                    multiplier: 1
                });
                this.render();
            }
            
            removeStep(index) {
                this.sequence.splice(index, 1);
                this.render();
            }
            
            updateStep(index, field, value) {
                if (!this.sequence[index]) return;
                
                if (field === 'type') {
                    this.sequence[index].type = value;
                    if (value === 'delay') {
                        this.sequence[index].value = 0.1;
                    } else if (value === 'combo') {
                        this.sequence[index].value = [];
                    } else {
                        this.sequence[index].value = '';
                    }
                } else {
                    this.sequence[index][field] = value;
                }
                this.render();
            }
            
            getSequence() {
                // Expand multipliers - if a step has multiplier > 1, duplicate it
                const expandedSequence = [];
                for (const step of this.sequence) {
                    const multiplier = parseInt(step.multiplier) || 1;
                    for (let i = 0; i < multiplier; i++) {
                        // Create a copy without the multiplier field
                        const { multiplier: _, ...stepWithoutMultiplier } = step;
                        expandedSequence.push(stepWithoutMultiplier);
                    }
                }
                return expandedSequence;
            }
            
            render() {
                if (!this.container) return;
                
                const builderIndex = this.container.dataset.index;
                
                console.log(`Rendering sequence for key ${builderIndex}:`, this.sequence);
                console.log(`Number of steps: ${this.sequence.length}`);
                
                this.container.innerHTML = `
                    <div class="sequence-builder">
                        ${this.sequence.map((step, i) => this.renderStep(step, i, builderIndex)).join('')}
                        <button class="sequence-add-step" onclick="sequenceBuilders[${builderIndex}].addStep()">
                            + Add Step
                        </button>
                    </div>
                `;
            }
            
            renderStep(step, index, builderIndex) {
                // Ensure step has multiplier (default to 1 for older sequences)
                if (!step.multiplier) step.multiplier = 1;
                
                const typeOptions = `
                    <option value="string" ${step.type === 'string' ? 'selected' : ''}>Type String</option>
                    <option value="key" ${step.type === 'key' ? 'selected' : ''}>Press Key</option>
                    <option value="combo" ${step.type === 'combo' ? 'selected' : ''}>Key Combo</option>
                    <option value="cc" ${step.type === 'cc' ? 'selected' : ''}>Media Key</option>
                    <option value="delay" ${step.type === 'delay' ? 'selected' : ''}>Delay (seconds)</option>
                `;
                
                let valueInput = '';
                
                if (step.type === 'string') {
                    const safeValue = this.escapeHtml(step.value || '');
                    valueInput = `<input type="text" value="${safeValue}" 
                        placeholder="Text to type" 
                        onchange="sequenceBuilders[${builderIndex}].updateStep(${index}, 'value', this.value)"
                        style="flex: 1; min-width: 200px;">`;
                } else if (step.type === 'key') {
                    valueInput = this.renderKeySelector(index, step.value, builderIndex);
                } else if (step.type === 'combo') {
                    valueInput = this.renderComboSelector(index, step.value || [], builderIndex);
                } else if (step.type === 'cc') {
                    valueInput = this.renderMediaKeySelector(index, step.value, builderIndex);
                } else if (step.type === 'delay') {
                    valueInput = `<input type="number" value="${step.value || 0.1}" 
                        min="0" max="10" step="0.1"
                        onchange="sequenceBuilders[${builderIndex}].updateStep(${index}, 'value', parseFloat(this.value))"
                        style="width: 100px;">`;
                }
                
                return `
                    <div class="sequence-step">
                        <div class="sequence-step-left">
                            <div class="sequence-step-number">${index + 1}</div>
                            <button class="sequence-step-remove" onclick="sequenceBuilders[${builderIndex}].removeStep(${index})" title="Remove step">✕</button>
                        </div>
                        <div class="sequence-step-content">
                            <select onchange="sequenceBuilders[${builderIndex}].updateStep(${index}, 'type', this.value)">
                                ${typeOptions}
                            </select>
                            ${valueInput}
                            <div style="display: flex; align-items: center; gap: 5px; margin-left: 10px;">
                                <label style="font-size: 0.9em; color: #b19cd9; white-space: nowrap;">×</label>
                                <input type="number" value="${step.multiplier || 1}" 
                                    min="1" max="100" 
                                    title="Repeat this step X times"
                                    onchange="sequenceBuilders[${builderIndex}].updateStep(${index}, 'multiplier', parseInt(this.value) || 1)"
                                    style="width: 60px;">
                            </div>
                        </div>
                    </div>
                `;
            }
            
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            renderKeySelector(index, currentValue, builderIndex) {
                return `
                    <select onchange="sequenceBuilders[${builderIndex}].updateStep(${index}, 'value', this.value)">
                        <option value="">Select Key</option>
                        ${KEYCODES.map(k => `<option value="${k}" ${currentValue === k ? 'selected' : ''}>${k}</option>`).join('')}
                    </select>
                `;
            }
            
            renderComboSelector(index, currentCombo, builderIndex) {
                const modifiers = ['CONTROL', 'SHIFT', 'ALT', 'WINDOWS', 'GUI'];
                const keys = KEYCODES;
                
                // Ensure currentCombo is an array
                const comboArray = Array.isArray(currentCombo) ? currentCombo : [];
                
                const renderSelect = (slotIndex) => {
                    const currentKey = comboArray[slotIndex] || '';
                    const options = slotIndex === 0 ? [...modifiers, ...keys] : keys;
                    
                    return `
                        <select onchange="
                            let combo = ${JSON.stringify(comboArray)};
                            if (this.value) {
                                combo[${slotIndex}] = this.value;
                            } else {
                                combo.splice(${slotIndex}, 1);
                            }
                            combo = combo.filter(k => k);
                            sequenceBuilders[${builderIndex}].updateStep(${index}, 'value', combo);
                        ">
                            <option value="">-</option>
                            ${options.map(k => `<option value="${k}" ${currentKey === k ? 'selected' : ''}>${k}</option>`).join('')}
                        </select>
                    `;
                };
                
                return `
                    <div class="combo-key-selector">
                        ${renderSelect(0)}
                        ${comboArray.length > 0 ? ' + ' : ''}
                        ${comboArray.length > 0 ? renderSelect(1) : ''}
                        ${comboArray.length > 1 ? ' + ' : ''}
                        ${comboArray.length > 1 ? renderSelect(2) : ''}
                    </div>
                `;
            }
            
            renderMediaKeySelector(index, currentValue, builderIndex) {
                return `
                    <select onchange="sequenceBuilders[${builderIndex}].updateStep(${index}, 'value', this.value)">
                        <option value="">Select Media Key</option>
                        ${CONSUMER_CONTROLS.map(k => `<option value="${k}" ${currentValue === k ? 'selected' : ''}>${k}</option>`).join('')}
                    </select>
                `;
            }
        }

        // ============================================
        // KEY GENERATION - NEW EXPLICIT FORMAT
        // ============================================
        function generateKeyData(keyIndex, layerIndex) {
            const keyType = getKeyType(keyIndex, layerIndex);
            
            if (keyType === 'none' || keyType === null) {
                return null;
            }
            
            if (keyType === 'string') {
                const value = getStringValue(keyIndex, layerIndex);
                if (!value) return null;
                return {"type": "string", "value": value};
            }
            
            if (keyType === 'key') {
                const value = getKeyValue(keyIndex, layerIndex);
                if (!value) return null;
                return {"type": "key", "value": value};
            }
            
            if (keyType === 'combo') {
                const keys = getComboKeys(keyIndex, layerIndex);
                const validKeys = keys.filter(k => k && k !== '');
                if (validKeys.length === 0) return null;
                return {"type": "combo", "value": validKeys};
            }
            
            if (keyType === 'url') {
                const value = getUrlValue(keyIndex, layerIndex);
                if (!value) return null;
                return {"type": "url", "value": value};
            }
            
            if (keyType === 'app') {
                const value = getAppValue(keyIndex, layerIndex);
                if (!value) return null;
                return {"type": "app", "value": value};
            }
            
            if (keyType === 'cc') {
                const value = getCCValue(keyIndex, layerIndex);
                if (!value) return null;
                return {"type": "cc", "value": value};
            }
            
            if (keyType === 'sequence') {
                if (sequenceBuilders[keyIndex]) {
                    const sequence = sequenceBuilders[keyIndex].getSequence();
                    if (sequence.length > 0) {
                        return {"type": "sequence", "value": sequence};
                    }
                }
                return null;
            }
            
            if (keyType === 'user') {
                const value = getUserValue(keyIndex, layerIndex);
                return value;
            }
            
            return null;
        }

        // ============================================
        // KEY LOADING - SUPPORTS BOTH FORMATS
        // ============================================
        function loadKeyData(keyData, keyIndex, layerIndex) {
            if (!keyData) {
                setKeyType(keyIndex, layerIndex, 'none');
                return;
            }
            
            // NEW EXPLICIT FORMAT
            if (typeof keyData === 'object' && keyData.type) {
                const keyType = keyData.type;
                const value = keyData.value;
                
                setKeyType(keyIndex, layerIndex, keyType);
                
                if (keyType === 'string') {
                    setStringValue(keyIndex, layerIndex, value);
                }
                else if (keyType === 'key') {
                    setKeyValue(keyIndex, layerIndex, value);
                }
                else if (keyType === 'combo') {
                    setComboKeys(keyIndex, layerIndex, value);
                }
                else if (keyType === 'url') {
                    setUrlValue(keyIndex, layerIndex, value);
                }
                else if (keyType === 'app') {
                    const cleanValue = value.startsWith('win:') ? value.substring(4) : value;
                    setAppValue(keyIndex, layerIndex, cleanValue);
                }
                else if (keyType === 'cc') {
                    setCCValue(keyIndex, layerIndex, value);
                }
                else if (keyType === 'sequence') {
                    setKeyType(keyIndex, layerIndex, 'sequence');
                    const containerId = `sequence-builder-${keyIndex}`;
                    sequenceBuilders[keyIndex] = new SequenceBuilder(containerId, value);
                }
                
                return;
            }
            
            // LEGACY FORMAT DETECTION
            if (typeof keyData === 'string') {
                if (keyData.startsWith('http://') || keyData.startsWith('https://')) {
                    setKeyType(keyIndex, layerIndex, 'url');
                    setUrlValue(keyIndex, layerIndex, keyData);
                }
                else if (keyData.startsWith('win:')) {
                    setKeyType(keyIndex, layerIndex, 'app');
                    setAppValue(keyIndex, layerIndex, keyData.substring(4));
                }
                else if (isValidKeycode(keyData)) {
                    if (CONSUMER_CONTROLS.includes(keyData)) {
                        setKeyType(keyIndex, layerIndex, 'cc');
                        setCCValue(keyIndex, layerIndex, keyData);
                    } else {
                        setKeyType(keyIndex, layerIndex, 'key');
                        setKeyValue(keyIndex, layerIndex, keyData);
                    }
                }
                else {
                    setKeyType(keyIndex, layerIndex, 'string');
                    setStringValue(keyIndex, layerIndex, keyData);
                }
            }
            else if (Array.isArray(keyData)) {
                setKeyType(keyIndex, layerIndex, 'combo');
                setComboKeys(keyIndex, layerIndex, keyData);
            }
        }

        function isValidKeycode(str) {
            return KEYCODES.includes(str) || CONSUMER_CONTROLS.includes(str);
        }

        // ============================================
        // UI FUNCTIONS
        // ============================================
        function updateLayerCount() {
            const input = document.getElementById('numLayers');
            let newCount = parseInt(input.value);
            
            // Enforce minimum of 2 layers
            if (newCount < 2) {
                newCount = 2;
                input.value = 2;
            }
            
            numLayers = newCount;
            initializeKeymapData();
            renderLayerTabs();
            renderCurrentLayer();
        }

        function initializeKeymapData() {
            // Initialize layer names
            while (keymapData.layer_names.length < numLayers) {
                keymapData.layer_names.push(`LAYER${keymapData.layer_names.length}`);
            }
            keymapData.layer_names = keymapData.layer_names.slice(0, numLayers);

            // Ensure default and secret are different and valid
            if (keymapData.secret_layer >= numLayers) {
                keymapData.secret_layer = 0;
            }
            if (keymapData.default_layer >= numLayers) {
                keymapData.default_layer = 1;
            }
            // Ensure they're not the same
            if (keymapData.secret_layer === keymapData.default_layer) {
                keymapData.secret_layer = 0;
                keymapData.default_layer = 1;
            }

            // Initialize keymap
            while (keymapData.keymap.length < numLayers) {
                keymapData.keymap.push(Array(8).fill(null));
            }
            keymapData.keymap = keymapData.keymap.slice(0, numLayers);

            // Initialize icons
            while (keymapData.icons.length < numLayers) {
                keymapData.icons.push(Array(8).fill('---'));
            }
            keymapData.icons = keymapData.icons.slice(0, numLayers);

            // Initialize encoder
            while (keymapData.encoder_icons.length < numLayers) {
                keymapData.encoder_icons.push('----');
            }
            keymapData.encoder_icons = keymapData.encoder_icons.slice(0, numLayers);

            while (keymapData.encoder_actions.length < numLayers) {
                keymapData.encoder_actions.push(null);
            }
            keymapData.encoder_actions = keymapData.encoder_actions.slice(0, numLayers);
        }

        function renderLayerTabs() {
            const tabsContainer = document.getElementById('layerTabs');
            tabsContainer.innerHTML = '';
            
            for (let i = 0; i < numLayers; i++) {
                const tab = document.createElement('div');
                tab.className = 'layer-tab' + (i === currentLayer ? ' active' : '');
                tab.textContent = keymapData.layer_names[i] || `Layer ${i}`;
                tab.onclick = () => switchLayer(i);
                tabsContainer.appendChild(tab);
            }
        }

        function switchLayer(layerIndex) {
            currentLayer = layerIndex;
            renderLayerTabs();
            renderCurrentLayer();
        }

        function renderCurrentLayer() {
            const content = document.getElementById('layerContent');
            
            let html = `
                <div class="input-group">
                    <label>Layer Name:</label>
                    <input type="text" value="${keymapData.layer_names[currentLayer]}" 
                           onchange="keymapData.layer_names[${currentLayer}] = this.value; renderLayerTabs();">
                </div>
                
                <div class="checkbox-inline">
                    <input type="checkbox" id="defaultCheck-${currentLayer}" 
                           ${keymapData.default_layer === currentLayer ? 'checked' : ''}
                           onchange="setDefaultLayer(${currentLayer}, this.checked);">
                    <label for="defaultCheck-${currentLayer}">Default Layer</label>
                    
                    <input type="checkbox" id="secretCheck-${currentLayer}" 
                           ${keymapData.secret_layer === currentLayer ? 'checked' : ''}
                           onchange="setSecretLayer(${currentLayer}, this.checked);"
                           style="margin-left: 30px;">
                    <label for="secretCheck-${currentLayer}">Secret Layer</label>
                </div>

                <div class="key-grid">
            `;
            
            for (let i = 0; i < 8; i++) {
                html += renderKeyConfig(i);
            }
            
            html += '</div>';
            
            // Encoder configuration
            html += `
                <h3>Encoder</h3>
                <div class="input-group">
                    <label>Encoder icon:</label>
                    <input type="text" maxlength="4" value="${keymapData.encoder_icons[currentLayer]}"
                           onchange="keymapData.encoder_icons[${currentLayer}] = this.value.toUpperCase();">
                </div>
                
                <div class="input-group">
                    <label>Encoder Action:</label>
                    <select id="encoderAction-${currentLayer}" onchange="updateEncoderAction(${currentLayer}, this.value)">
                        <option value="none">None</option>
                        <option value="volume">Volume</option>
                        <option value="scroll">Scroll</option>
                        <option value="zoom">Zoom</option>
                    </select>
                </div>
            `;
            
            content.innerHTML = html;
            
            // Set encoder action dropdown value
            const encoderAction = keymapData.encoder_actions[currentLayer];
            const encoderSelect = document.getElementById(`encoderAction-${currentLayer}`);
            if (encoderSelect && encoderAction) {
                if (encoderAction.cc === "VOL_UP") {
                    encoderSelect.value = "volume";
                } else if (encoderAction.mouse_wheel) {
                    encoderSelect.value = "scroll";
                } else if (encoderAction.combo) {
                    encoderSelect.value = "zoom";
                }
            }
            
            // Initialize sequence builders for visible keys
            for (let i = 0; i < 8; i++) {
                const keyData = keymapData.keymap[currentLayer][i];
                if (keyData && keyData.type === 'sequence') {
                    console.log(`Loading sequence for key ${i}:`, keyData.value);
                    const containerId = `sequence-builder-${i}`;
                    const container = document.getElementById(containerId);
                    if (container) {
                        container.dataset.index = i;
                        // Deep clone the sequence data to avoid reference issues
                        const sequenceData = JSON.parse(JSON.stringify(keyData.value || []));
                        console.log(`Cloned sequence data for key ${i}:`, sequenceData);
                        sequenceBuilders[i] = new SequenceBuilder(containerId, sequenceData);
                    }
                }
            }
        }

        function setDefaultLayer(layerIndex, checked) {
            if (checked) {
                // If setting as default, unset as secret
                if (keymapData.secret_layer === layerIndex) {
                    // Find another layer to be secret (prefer layer 0)
                    keymapData.secret_layer = layerIndex === 0 ? 1 : 0;
                }
                keymapData.default_layer = layerIndex;
            } else {
                // Can't uncheck default - must always have one
                // Set to another layer (prefer layer 1, but not the secret layer)
                let newDefault = layerIndex === 1 ? 0 : 1;
                if (newDefault === keymapData.secret_layer) {
                    // Find first layer that isn't secret
                    for (let i = 0; i < numLayers; i++) {
                        if (i !== keymapData.secret_layer) {
                            newDefault = i;
                            break;
                        }
                    }
                }
                keymapData.default_layer = newDefault;
            }
            renderCurrentLayer();
        }

        function setSecretLayer(layerIndex, checked) {
            if (checked) {
                // If setting as secret, unset as default
                if (keymapData.default_layer === layerIndex) {
                    // Find another layer to be default (prefer layer 1)
                    keymapData.default_layer = layerIndex === 1 ? 0 : 1;
                }
                keymapData.secret_layer = layerIndex;
            } else {
                // Can't uncheck secret - must always have one
                // Set to another layer (prefer layer 0, but not the default layer)
                let newSecret = layerIndex === 0 ? 1 : 0;
                if (newSecret === keymapData.default_layer) {
                    // Find first layer that isn't default
                    for (let i = 0; i < numLayers; i++) {
                        if (i !== keymapData.default_layer) {
                            newSecret = i;
                            break;
                        }
                    }
                }
                keymapData.secret_layer = newSecret;
            }
            renderCurrentLayer();
        }

        function renderKeyConfig(keyIndex) {
            const keyData = keymapData.keymap[currentLayer][keyIndex];
            let keyType = 'none';
            let keyValue = '';
            
            console.log(`renderKeyConfig - Layer ${currentLayer}, Key ${keyIndex}:`, keyData);
            
            if (keyData !== null && typeof keyData === 'object' && keyData.type) {
                keyType = keyData.type;
                keyValue = keyData.value;
                console.log(`  - Detected type: ${keyType}, value:`, keyValue);
            } else {
                console.log(`  - No valid keyData (null, not object, or no type property)`);
            }
            
            const icon = keymapData.icons[currentLayer][keyIndex];
            
            return `
                <div class="key-config">
                    <h3>Key ${keyIndex}</h3>
                    
                    <label>Icon:</label>
                    <input type="text" maxlength="4" value="${icon}" 
                           onchange="keymapData.icons[${currentLayer}][${keyIndex}] = this.value.toUpperCase();">
                    
                    <label>Key Type:</label>
                    <select id="keyType-${keyIndex}" onchange="changeKeyType(${keyIndex}, this.value)">
                        <option value="none" ${keyType === 'none' ? 'selected' : ''}>None</option>
                        <option value="string" ${keyType === 'string' ? 'selected' : ''}>String</option>
                        <option value="key" ${keyType === 'key' ? 'selected' : ''}>Key</option>
                        <option value="combo" ${keyType === 'combo' ? 'selected' : ''}>Combo</option>
                        <option value="url" ${keyType === 'url' ? 'selected' : ''}>URL</option>
                        <option value="app" ${keyType === 'app' ? 'selected' : ''}>App</option>
                        <option value="cc" ${keyType === 'cc' ? 'selected' : ''}>Media Key</option>
                        <option value="sequence" ${keyType === 'sequence' ? 'selected' : ''}>Sequence</option>
                        <option value="user" ${keyType === 'user' ? 'selected' : ''}>Macro Recorder</option>
                    </select>
                    
                    <div id="keyInput-${keyIndex}">
                        ${renderKeyInput(keyIndex, keyType, keyValue)}
                    </div>
                    
                    <div id="sequence-builder-${keyIndex}" data-index="${keyIndex}" style="display:${keyType === 'sequence' ? 'block' : 'none'}"></div>
                </div>
            `;
        }

        function renderKeyInput(keyIndex, keyType, keyValue) {
            if (keyType === 'none') return '';
            
            if (keyType === 'string') {
                return `
                    <label>Text to type:</label>
                    <input type="text" id="keyValue-${keyIndex}" value="${keyValue || ''}" 
                           placeholder="Enter text">
                `;
            }
            
            if (keyType === 'key') {
                return `
                    <label>Key:</label>
                    <select id="keyValue-${keyIndex}">
                        <option value="">Select Key</option>
                        ${KEYCODES.map(k => `<option value="${k}" ${keyValue === k ? 'selected' : ''}>${k}</option>`).join('')}
                    </select>
                `;
            }
            
            if (keyType === 'combo') {
                const comboKeys = Array.isArray(keyValue) ? keyValue : [];
                return `
                    <label>Key Combination:</label>
                    <div class="combo-selector">
                        <select id="combo1-${keyIndex}">
                            <option value="">-</option>
                            ${['CONTROL', 'SHIFT', 'ALT', 'WINDOWS', 'GUI', ...KEYCODES].map(k => 
                                `<option value="${k}" ${comboKeys[0] === k ? 'selected' : ''}>${k}</option>`
                            ).join('')}
                        </select>
                        <span>+</span>
                        <select id="combo2-${keyIndex}">
                            <option value="">-</option>
                            ${KEYCODES.map(k => 
                                `<option value="${k}" ${comboKeys[1] === k ? 'selected' : ''}>${k}</option>`
                            ).join('')}
                        </select>
                        <span>+</span>
                        <select id="combo3-${keyIndex}">
                            <option value="">-</option>
                            ${KEYCODES.map(k => 
                                `<option value="${k}" ${comboKeys[2] === k ? 'selected' : ''}>${k}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;
            }
            
            if (keyType === 'url') {
                return `
                    <label>URL:</label>
                    <input type="text" id="keyValue-${keyIndex}" value="${keyValue || ''}" 
                           placeholder="https://example.com">
                `;
            }
            
            if (keyType === 'app') {
                return `
                    <label>Application Path:</label>
                    <input type="text" id="keyValue-${keyIndex}" value="${keyValue || ''}" 
                           placeholder="C:\\Program Files\\App\\app.exe">
                    <small>Full path to executable</small>
                `;
            }
            
            if (keyType === 'cc') {
                return `
                    <label>Media Control:</label>
                    <select id="keyValue-${keyIndex}">
                        <option value="">Select</option>
                        ${CONSUMER_CONTROLS.map(k => 
                            `<option value="${k}" ${keyValue === k ? 'selected' : ''}>${k}</option>`
                        ).join('')}
                    </select>
                `;
            }
            
            if (keyType === 'user') {
                return `
                    <div class="label-with-button">
                        <label style="margin: 0;">Macro Recorder JSON:</label>
                        <button class="macro-recorder-button" onclick="openMacroRecorder()">Macro Recorder</button>
                        <button class="macro-recorder-button" onclick="validateMacroJSON(${keyIndex})" style="background: #3498db;">Validate</button>
                    </div>
                    <div class="textarea-wrapper">
                        <textarea id="keyValue-${keyIndex}" rows="3">${JSON.stringify(keyValue) || ''}</textarea>
                        <button class="expand-button" onclick="openJsonModal(${keyIndex})" title="Expand editor">⛶</button>
                    </div>
                    <small>Paste JSON from Macro Recorder here (auto-detects sequences)</small>
                `;
            }
            
            return '';
        }

        function changeKeyType(keyIndex, newType) {
            // Save current data before changing type
            saveCurrentKeyData(keyIndex);
            
            // Update display
            const inputDiv = document.getElementById(`keyInput-${keyIndex}`);
            inputDiv.innerHTML = renderKeyInput(keyIndex, newType, '');
            
            // Show/hide sequence builder
            const seqBuilder = document.getElementById(`sequence-builder-${keyIndex}`);
            if (newType === 'sequence') {
                seqBuilder.style.display = 'block';
                seqBuilder.dataset.index = keyIndex;
                if (!sequenceBuilders[keyIndex]) {
                    sequenceBuilders[keyIndex] = new SequenceBuilder(seqBuilder.id, []);
                }
            } else {
                seqBuilder.style.display = 'none';
            }
        }

        function saveCurrentKeyData(keyIndex) {
            let keyType = document.getElementById(`keyType-${keyIndex}`).value;
            
            if (keyType === 'none') {
                keymapData.keymap[currentLayer][keyIndex] = null;
                return;
            }
            
            let value = null;
            
            if (keyType === 'combo') {
                const combo1 = document.getElementById(`combo1-${keyIndex}`)?.value;
                const combo2 = document.getElementById(`combo2-${keyIndex}`)?.value;
                const combo3 = document.getElementById(`combo3-${keyIndex}`)?.value;
                value = [combo1, combo2, combo3].filter(k => k);
            } else if (keyType === 'sequence') {
                if (sequenceBuilders[keyIndex]) {
                    value = sequenceBuilders[keyIndex].getSequence();
                }
            } else if (keyType === 'user') {
                try {
                    const textValue = document.getElementById(`keyValue-${keyIndex}`)?.value;
                    
                    // Debug logging
                    console.log('=== MACRO RECORDER FIELD DEBUG ===');
                    console.log('Raw text value:', textValue);
                    console.log('Text length:', textValue?.length);
                    
                    if (!textValue || textValue.trim() === '') {
                        console.log('Field is empty');
                        value = null;
                    } else {
                        // Try to parse
                        value = JSON.parse(textValue);
                        console.log('Parsed successfully:', value);
                        console.log('Is array:', Array.isArray(value));
                        
                        // Auto-detect if this is a sequence (array of step objects)
                        if (Array.isArray(value) && value.length > 0) {
                            console.log('Checking if looks like sequence...');
                            console.log('First element:', value[0]);
                            
                            // Check if it looks like a sequence (has type/value properties)
                            const looksLikeSequence = value.every(step => 
                                step && typeof step === 'object' && 'type' in step
                            );
                            
                            console.log('Looks like sequence:', looksLikeSequence);
                            
                            if (looksLikeSequence) {
                                // This is a sequence from the Macro Recorder
                                // Change keyType to 'sequence' so it saves correctly
                                keyType = 'sequence';
                                console.log(`Auto-detected sequence in Macro Recorder field for key ${keyIndex}`);
                            }
                        }
                    }
                    console.log('=== END DEBUG ===');
                } catch (e) {
                    console.error('JSON Parse Error:', e);
                    console.error('Error message:', e.message);
                    console.error('Failed text:', document.getElementById(`keyValue-${keyIndex}`)?.value);
                    alert('Invalid JSON in Macro Recorder field\n\nError: ' + e.message + '\n\nCheck browser console (F12) for details.');
                    return;
                }
            } else {
                value = document.getElementById(`keyValue-${keyIndex}`)?.value || '';
            }
            
            if (keyType && value !== null && value !== '') {
                keymapData.keymap[currentLayer][keyIndex] = {
                    type: keyType,
                    value: value
                };
            } else {
                keymapData.keymap[currentLayer][keyIndex] = null;
            }
        }

        // Getter functions
        function getKeyType(keyIndex, layerIndex) {
            const keyData = keymapData.keymap[layerIndex][keyIndex];
            if (!keyData) return 'none';
            if (typeof keyData === 'object' && keyData.type) return keyData.type;
            return 'none';
        }

        function getStringValue(keyIndex, layerIndex) {
            return document.getElementById(`keyValue-${keyIndex}`)?.value || '';
        }

        function getKeyValue(keyIndex, layerIndex) {
            return document.getElementById(`keyValue-${keyIndex}`)?.value || '';
        }

        function getComboKeys(keyIndex, layerIndex) {
            const combo1 = document.getElementById(`combo1-${keyIndex}`)?.value;
            const combo2 = document.getElementById(`combo2-${keyIndex}`)?.value;
            const combo3 = document.getElementById(`combo3-${keyIndex}`)?.value;
            return [combo1, combo2, combo3].filter(k => k);
        }

        function getUrlValue(keyIndex, layerIndex) {
            return document.getElementById(`keyValue-${keyIndex}`)?.value || '';
        }

        function getAppValue(keyIndex, layerIndex) {
            return document.getElementById(`keyValue-${keyIndex}`)?.value || '';
        }

        function getCCValue(keyIndex, layerIndex) {
            return document.getElementById(`keyValue-${keyIndex}`)?.value || '';
        }

        function getUserValue(keyIndex, layerIndex) {
            try {
                const value = document.getElementById(`keyValue-${keyIndex}`)?.value;
                return value ? JSON.parse(value) : null;
            } catch (e) {
                return null;
            }
        }

        // Setter functions
        function setKeyType(keyIndex, layerIndex, type) {
            const select = document.getElementById(`keyType-${keyIndex}`);
            if (select) select.value = type;
        }

        function setStringValue(keyIndex, layerIndex, value) {
            const input = document.getElementById(`keyValue-${keyIndex}`);
            if (input) input.value = value;
        }

        function setKeyValue(keyIndex, layerIndex, value) {
            const select = document.getElementById(`keyValue-${keyIndex}`);
            if (select) select.value = value;
        }

        function setComboKeys(keyIndex, layerIndex, keys) {
            const combo1 = document.getElementById(`combo1-${keyIndex}`);
            const combo2 = document.getElementById(`combo2-${keyIndex}`);
            const combo3 = document.getElementById(`combo3-${keyIndex}`);
            if (combo1 && keys[0]) combo1.value = keys[0];
            if (combo2 && keys[1]) combo2.value = keys[1];
            if (combo3 && keys[2]) combo3.value = keys[2];
        }

        function setUrlValue(keyIndex, layerIndex, value) {
            const input = document.getElementById(`keyValue-${keyIndex}`);
            if (input) input.value = value;
        }

        function setAppValue(keyIndex, layerIndex, value) {
            const input = document.getElementById(`keyValue-${keyIndex}`);
            if (input) input.value = value;
        }

        function setCCValue(keyIndex, layerIndex, value) {
            const select = document.getElementById(`keyValue-${keyIndex}`);
            if (select) select.value = value;
        }

        function updateEncoderAction(layerIndex, action) {
            if (action === 'none') {
                keymapData.encoder_actions[layerIndex] = null;
            } else if (action === 'volume') {
                keymapData.encoder_actions[layerIndex] = {"cc": "VOL_UP"};
            } else if (action === 'scroll') {
                keymapData.encoder_actions[layerIndex] = {"mouse_wheel": 1};
            } else if (action === 'zoom') {
                keymapData.encoder_actions[layerIndex] = {
                    "combo": ["CONTROL", "KEYPAD_PLUS"],
                    "combo_ccw": ["CONTROL", "KEYPAD_MINUS"]
                };
            }
        }

        function generateKeymap() {
            // Save current layer data
            for (let i = 0; i < 8; i++) {
                saveCurrentKeyData(i);
            }
            
            // Generate complete keymap
            const output = {
                layer_names: keymapData.layer_names,
                secret_layer: keymapData.secret_layer,
                default_layer: keymapData.default_layer,
                keymap: keymapData.keymap,
                icons: keymapData.icons,
                encoder_icons: keymapData.encoder_icons,
                encoder_actions: keymapData.encoder_actions
            };
            
            const jsonStr = JSON.stringify(output, null, 2);
            document.getElementById('jsonOutput').value = jsonStr;
        }

        function saveKeymap() {
            generateKeymap();
            const jsonStr = document.getElementById('jsonOutput').value;
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'keymap.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function clearAll() {
            document.getElementById('jsonOutput').value = '';
        }

        // File loading
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const data = JSON.parse(event.target.result);
                    
                    console.log('=== LOADING KEYMAP ===');
                    console.log('Full data:', data);
                    console.log('Keymap structure check:');
                    console.log('  - data.keymap exists:', !!data.keymap);
                    console.log('  - data.keymap is array:', Array.isArray(data.keymap));
                    if (data.keymap && data.keymap[0]) {
                        console.log('  - Layer 0:', data.keymap[0]);
                        console.log('  - Layer 0 is array:', Array.isArray(data.keymap[0]));
                        console.log('  - Layer 0, Key 0:', data.keymap[0][0]);
                    }
                    
                    // Load data
                    keymapData = data;
                    
                    // AUTO-CONVERT shorthand format to full format
                    console.log('=== CHECKING FORMAT ===');
                    let needsConversion = false;
                    
                    // Check if any key uses shorthand format
                    if (data.keymap && Array.isArray(data.keymap)) {
                        for (let layer of data.keymap) {
                            if (Array.isArray(layer)) {
                                for (let key of layer) {
                                    if (key !== null && typeof key !== 'object') {
                                        needsConversion = true;
                                        break;
                                    }
                                    if (Array.isArray(key)) {
                                        needsConversion = true;
                                        break;
                                    }
                                }
                            }
                            if (needsConversion) break;
                        }
                    }
                    
                    if (needsConversion) {
                        console.log('Shorthand format detected - converting to full format...');
                        
                        // Convert keymap
                        const mediaKeys = ['MUTE', 'VOL_UP', 'VOL_DOWN', 'PLAY_PAUSE', 'PLAYPAUSE', 
                                          'PREV', 'NEXT', 'STOP', 'EJECT', 'FAST_FORWARD', 'REWIND'];
                        
                        let conversionStats = {
                            string: 0,
                            key: 0,
                            combo: 0,
                            url: 0,
                            app: 0,
                            cc: 0,
                            null: 0
                        };
                        
                        keymapData.keymap = data.keymap.map((layer, layerIdx) => {
                            return layer.map((key, keyIdx) => {
                                // null stays null
                                if (key === null) {
                                    conversionStats.null++;
                                    return null;
                                }
                                
                                // Already in full format
                                if (typeof key === 'object' && !Array.isArray(key) && key.type) {
                                    return key;
                                }
                                
                                // Array = combo
                                if (Array.isArray(key)) {
                                    conversionStats.combo++;
                                    console.log(`  Layer ${layerIdx}, Key ${keyIdx}: [${key.join(', ')}] → combo`);
                                    return {type: 'combo', value: key};
                                }
                                
                                // String - need to detect what type
                                if (typeof key === 'string') {
                                    // URL
                                    if (key.startsWith('http://') || key.startsWith('https://')) {
                                        conversionStats.url++;
                                        console.log(`  Layer ${layerIdx}, Key ${keyIdx}: "${key.substring(0, 30)}..." → url`);
                                        return {type: 'url', value: key};
                                    }
                                    // App (Windows app format)
                                    if (key.startsWith('win:') || key.startsWith('mac:') || key.startsWith('linux:')) {
                                        conversionStats.app++;
                                        console.log(`  Layer ${layerIdx}, Key ${keyIdx}: "${key.substring(0, 30)}..." → app`);
                                        return {type: 'app', value: key};
                                    }
                                    // Media key (check against known list)
                                    if (mediaKeys.includes(key.toUpperCase())) {
                                        conversionStats.cc++;
                                        console.log(`  Layer ${layerIdx}, Key ${keyIdx}: "${key}" → media key (cc)`);
                                        return {type: 'cc', value: key.toUpperCase()};
                                    }
                                    // Known keycode = key
                                    if (KEYCODES.includes(key.toUpperCase())) {
                                        conversionStats.key++;
                                        console.log(`  Layer ${layerIdx}, Key ${keyIdx}: "${key}" → key`);
                                        return {type: 'key', value: key.toUpperCase()};
                                    }
                                    // Everything else = string to type
                                    conversionStats.string++;
                                    console.log(`  Layer ${layerIdx}, Key ${keyIdx}: "${key}" → string`);
                                    return {type: 'string', value: key};
                                }
                                
                                // Unknown format - return null
                                console.warn('Unknown key format:', key);
                                return null;
                            });
                        });
                        
                        console.log('Conversion complete!');
                        console.log('Stats:', conversionStats);
                    } else {
                        console.log('Full format detected - no conversion needed');
                    }
                    
                    numLayers = data.layer_names.length;
                    document.getElementById('numLayers').value = numLayers;
                    
                    // Validate loaded data structure
                    console.log('=== VALIDATING LOADED DATA ===');
                    let validationPassed = true;
                    
                    // Check if keymap exists and has correct number of layers
                    if (!keymapData.keymap || !Array.isArray(keymapData.keymap)) {
                        console.error('ERROR: keymap is missing or not an array');
                        validationPassed = false;
                    } else if (keymapData.keymap.length !== numLayers) {
                        console.warn(`WARNING: keymap has ${keymapData.keymap.length} layers but layer_names has ${numLayers}`);
                    }
                    
                    // Check each layer
                    for (let i = 0; i < Math.min(numLayers, keymapData.keymap?.length || 0); i++) {
                        if (!Array.isArray(keymapData.keymap[i])) {
                            console.error(`ERROR: Layer ${i} is not an array:`, keymapData.keymap[i]);
                            validationPassed = false;
                        } else if (keymapData.keymap[i].length !== 8) {
                            console.warn(`WARNING: Layer ${i} has ${keymapData.keymap[i].length} keys (expected 8)`);
                        } else {
                            // Check each key in the layer
                            for (let j = 0; j < 8; j++) {
                                const key = keymapData.keymap[i][j];
                                if (key !== null && typeof key === 'object' && key.type) {
                                    console.log(`  ✓ Layer ${i}, Key ${j}: type=${key.type}, value=`, key.value);
                                } else if (key === null) {
                                    console.log(`  - Layer ${i}, Key ${j}: null (unassigned)`);
                                } else {
                                    console.warn(`  ⚠ Layer ${i}, Key ${j}: unexpected format:`, key);
                                }
                            }
                        }
                    }
                    
                    if (!validationPassed) {
                        alert('WARNING: Loaded keymap has structural issues. Check console (F12) for details.');
                    }
                    
                    console.log('=== END VALIDATION ===');
                    
                    // Clear existing sequence builders
                    sequenceBuilders = [];
                    
                    // Reset to layer 0 to avoid out-of-bounds
                    currentLayer = 0;
                    
                    // Log sequences in data
                    data.keymap.forEach((layer, layerIdx) => {
                        layer.forEach((key, keyIdx) => {
                            if (key && key.type === 'sequence') {
                                console.log(`Layer ${layerIdx}, Key ${keyIdx} has sequence:`, key.value);
                                console.log(`  - Number of steps: ${key.value.length}`);
                                key.value.forEach((step, stepIdx) => {
                                    console.log(`  - Step ${stepIdx}:`, step);
                                });
                            }
                        });
                    });
                    
                    // Render
                    renderLayerTabs();
                    renderCurrentLayer();
                    
                    console.log('=== LOAD COMPLETE ===');
                    alert('Keymap loaded successfully!\nCheck console (F12) for details.');
                } catch (err) {
                    alert('Error loading file: ' + err.message);
                    console.error('Load error:', err);
                }
            };
            reader.readAsText(file);
        });

        // Initialize on load
        initializeKeymapData();
        renderLayerTabs();
        renderCurrentLayer();
        
        function openHelp() {
            window.open('https://mp1-help.theornerymaker.com', '_blank');
        }
        
        function validateMacroJSON(keyIndex) {
            const textValue = document.getElementById(`keyValue-${keyIndex}`)?.value;
            
            console.log('=== VALIDATING MACRO JSON ===');
            console.log('Raw value:', textValue);
            console.log('Length:', textValue?.length);
            
            if (!textValue || textValue.trim() === '') {
                alert('Field is empty. Paste JSON from Macro Recorder first.');
                return;
            }
            
            try {
                const parsed = JSON.parse(textValue);
                console.log('✓ Valid JSON');
                console.log('Parsed value:', parsed);
                console.log('Type:', typeof parsed);
                console.log('Is array:', Array.isArray(parsed));
                
                if (Array.isArray(parsed)) {
                    console.log('Array length:', parsed.length);
                    
                    // Check if it looks like a sequence
                    const hasTypeProperty = parsed.every(item => 
                        item && typeof item === 'object' && 'type' in item
                    );
                    
                    if (hasTypeProperty) {
                        console.log('✓ Looks like a sequence from Macro Recorder');
                        console.log('First item:', parsed[0]);
                        alert('✓ Valid JSON!\n\n' +
                              'Format: Sequence array\n' +
                              'Length: ' + parsed.length + ' steps\n' +
                              'First step type: ' + parsed[0].type + '\n\n' +
                              'This will be auto-detected as a sequence when you download.');
                    } else {
                        console.warn('⚠ Array but does not look like a sequence');
                        alert('✓ Valid JSON (array with ' + parsed.length + ' items)\n\n' +
                              '⚠ Warning: Does not look like a Macro Recorder sequence.\n' +
                              'Expected objects with "type" property.');
                    }
                } else if (typeof parsed === 'object') {
                    console.log('✓ Valid object');
                    alert('✓ Valid JSON (object)\n\n' +
                          'Note: Macro Recorder outputs arrays. This is an object.\n' +
                          'It will be saved as-is.');
                } else {
                    console.log('✓ Valid but not array or object');
                    alert('✓ Valid JSON\n\nType: ' + typeof parsed);
                }
                
                console.log('=== END VALIDATION ===');
            } catch (e) {
                console.error('✗ Invalid JSON');
                console.error('Error:', e.message);
                console.error('Error at position:', e.message.match(/position (\d+)/)?.[1]);
                
                // Try to highlight the error location
                let errorMsg = '✗ Invalid JSON\n\n' +
                              'Error: ' + e.message + '\n\n';
                
                // Show first 100 chars of the text
                if (textValue.length > 100) {
                    errorMsg += 'First 100 characters:\n' + textValue.substring(0, 100) + '...\n\n';
                }
                
                errorMsg += 'Check console (F12) for details.';
                
                alert(errorMsg);
                console.log('=== END VALIDATION ===');
            }
        }
        
        function openMacroRecorder() {
            window.open('macro_recorder.html', '_blank');
        }
        
        // JSON Modal functions
        let currentModalKeyIndex = null;
        
        function openJsonModal(keyIndex) {
            currentModalKeyIndex = keyIndex;
            const textarea = document.getElementById(`keyValue-${keyIndex}`);
            const modal = document.getElementById('jsonModal');
            const modalTextarea = document.getElementById('modalJsonTextarea');
            
            if (textarea && modal && modalTextarea) {
                modalTextarea.value = textarea.value;
                modal.classList.add('active');
            }
        }
        
        function closeJsonModal() {
            const modal = document.getElementById('jsonModal');
            modal.classList.remove('active');
            currentModalKeyIndex = null;
        }
        
        function saveJsonModal() {
            if (currentModalKeyIndex !== null) {
                const textarea = document.getElementById(`keyValue-${currentModalKeyIndex}`);
                const modalTextarea = document.getElementById('modalJsonTextarea');
                
                if (textarea && modalTextarea) {
                    textarea.value = modalTextarea.value;
                }
            }
            closeJsonModal();
        }
        
        // Close modal when clicking outside
        document.addEventListener('DOMContentLoaded', function() {
            const modal = document.getElementById('jsonModal');
            if (modal) {
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        closeJsonModal();
                    }
                });
            }
        });
        
        // Close modal with ESC key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const modal = document.getElementById('jsonModal');
                if (modal && modal.classList.contains('active')) {
                    closeJsonModal();
                }
            }
        });
    </script>
    
    <!-- JSON Editor Modal -->
    <div id="jsonModal" class="json-modal">
        <div class="json-modal-content">
            <div class="json-modal-header">
                <h3>JSON Editor</h3>
                <button class="json-modal-close" onclick="closeJsonModal()">×</button>
            </div>
            <div class="json-modal-body">
                <textarea id="modalJsonTextarea" placeholder="Enter JSON here..."></textarea>
            </div>
            <div class="json-modal-footer">
                <button onclick="closeJsonModal()" style="background: #555;">Cancel</button>
                <button onclick="saveJsonModal()">Save</button>
            </div>
        </div>
    </div>
</body>
</html>
